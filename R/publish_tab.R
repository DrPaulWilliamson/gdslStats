#' Convert `tab` object to publication standard
#'
#' @param res A tabulation stored as a data object of class `tab` (e.g. the output from the `tab` function).
#' @param line_width The line width to use when drawing any horizontal lines in the table (Default is 1.2).
#'
#' @return A publication-standard version of the input table, returned as a `flextable` data object.
#' @export
#'
#' @examples
#' # Create a tabulation using the `tab` function
#' example_table <- survey |>
#'   tab( Age ~ Sex, measure = "row_pct", totals = "row", base_count = TRUE )
#'
#' # Create publication standard version
#' publish_tab( example_table )
#'
#' # As above, but with rounding (which must happen before publish_tab is called)
#' example_table |> round( dp = 0 ) |> publish_tab( )
publish_tab <- function( res, line_width = 1.2 ) {

  # Check supplied data object is of right kind
  if ( ("tab" %in% class( res ) ) == FALSE )
    stop("Supplied data object not generated by the tab function", call. = F )

  n_vars <- attributes(res)$n_vars
  totals <- attributes(res)$totals
  base_count <- attributes(res)$base_count
  metric <- attributes(res)$metric
  metric_type <- attributes(res)$metric_type

  # 1d tables only: change column name from text to publication standard symbol
  if (n_vars == 1) {
    col_name <- colnames( res )
    colnames( res ) <-
      dplyr::case_when( col_name == "Frequency" ~ "N",
                        col_name == "Percentage" ~ "%",
                        col_name == "Proportion" ~ "Proportion")
  }

  # Capture row and column and third variable names
  row_var_name <- names(dimnames(res))[1]
  if (n_vars > 1 ) col_var_name <- names(dimnames(res))[2]
  if (n_vars == 3) third_var_name <- names(dimnames(res)[3])

  # Identify variable to be used for pivoting data.frame to wide format
  if (n_vars == 1) {
    pivot_var <- "Var2"
  } else {
    pivot_var <- col_var_name
  }

  # Convert result from table to data.frame format
  res_df <- res |>
    # Convert table to (long) data.frame
    as.data.frame() |>
    # Convert table from long to wide format
    tidyr::pivot_wider( names_from = dplyr::all_of(pivot_var),
                        values_from = Freq)

  # capture further table information
  n_inner_table_rows <- dim(res)[1]
  n_col_categories <- dim(res)[2]
  n_inner_tables <- 1
  if (n_vars == 3) {
    n_inner_tables <- dim(res)[3]
    third_var_categories <- unlist(dimnames(res)[3])
  }

  # Insert one extra row per inner table from third dimension (3d tables only)
  # and place dimension name in first column (with NAs in remainder,
  # which flextable will render as blanks)
  if (n_vars == 3) {
    for (i in 1:n_inner_tables) {
      j <- i + (i-1)*n_inner_table_rows
      res_df <- res_df |>
        dplyr::add_row( {{row_var_name}} := third_var_categories[i],
                        .before = j )
    }
    n_inner_table_rows <- n_inner_table_rows + 1
  }

  # For 3d tables only, drop the 2nd column, which contains redundant
  # information concerning which 3d inner-table each row represents,
  # which has now been incorporated into the second colum
  # into the first column
  if (n_vars == 3) res_df <-
    res_df |>
    dplyr::select( -dplyr::all_of(third_var_name) )

  # Convert first column to a factor with NAs treated as a factor level,
  # [otherwise flextable won't display the NAs as a valid row category name]
  res_df <- res_df |>
    dplyr::mutate("{row_var_name}" :=
                    factor( .data[[row_var_name]],
                            levels = unique( .data[[row_var_name]] )
                    ) ) |>
    dplyr::mutate("{row_var_name}" :=
                    forcats::fct_na_value_to_level( .data[[row_var_name]] , level=NA ) )

  # Convert result from table to flextable format
  res_ft <- res_df |>
    flextable::flextable()

  #  Capture key table information needed to help format table

  # Table width
  table_cols <- ncol(res_df)

  # Row base count column (if any)
  if ( base_count == T & metric_type == "row")
    base_col <- table_cols

  # Row total column (if any)
  if (totals %in% c("row", "row_col")) {
    if ( base_count == T & metric_type == "row") {
      # If row base count column present
      total_col <- table_cols - 1
    } else {
      # If row base count column absent
      total_col <- table_cols
    }
  }

  # Number of categories in column variable
  n_col_categories <- table_cols - 1
  if ( totals %in% c("row", "row_col") )
    n_col_categories <- n_col_categories - 1
  if ( base_count == TRUE & metric_type == "row" )
    n_col_categories <- n_col_categories - 1

  if (n_vars == 3) {
    n_inner_tables <- dim(res)[3]
    third_var_categories <- unlist(dimnames(res)[3])
  }

  # Add a top header row to be used for reporting column variable name
  if (n_vars > 1) {
    res_ft <- flextable::add_header_row( res_ft,
                                         colwidths = rep(1, table_cols),
                                         values= rep("", table_cols, ""),
                                         top = TRUE)
  }

  # Identify number of header rows and, if a 2- or 3-way table
  # AND metric is percentage or proportion, add a bottom header row
  # to report unit of measure (percentage/proportion)
  if ( n_vars == 1) {
    n_header_rows <- 1
  } else if (metric %in% c("pct", "prop") ) {
    res_ft <- flextable::add_header_row( res_ft,
                                         colwidths = rep(1, table_cols),
                                         values= rep("", table_cols),
                                         top = FALSE)
    n_header_rows <- 3
  } else {
    n_header_rows <- 2
  }

  # Merge cells in first column of header (which wipes any text in these cells),
  # then replace the text (variable name) that has been wiped (unless a 1d table)
  if (n_vars > 1) {
    res_ft <-
      flextable::merge_at( res_ft, part="header", i=1:n_header_rows, j=1)

    res_ft <- flextable::compose( res_ft,
                                  part = "header",
                                  i = 1:n_header_rows,
                                  j = 1,
                                  flextable::as_paragraph( row_var_name ) )
  }

  # Merge cells in row total column (if any), then replace the text (Total)
  # that has been lost through the merger (unless 1d table)
  if ( n_vars > 1 & totals %in% c("row", "row_col" ) ) {
    res_ft <-
      flextable::merge_at( res_ft, part="header",
                           i=1:n_header_rows, j=total_col )

    res_ft <- flextable::compose( res_ft,
                                  part = "header",
                                  i = 1:n_header_rows,
                                  j = total_col,
                                  flextable::as_paragraph( "Total" ) )
  }

  # Merge cells in row base count column (if any), then replace the text (N)
  # that has been lost through the merger (unless 1d table)
  if ( n_vars > 1 & base_count == TRUE & metric_type == "row" ) {
    res_ft <-
      flextable::merge_at( res_ft, part="header",
                           i=1:n_header_rows, j=base_col )

    res_ft <- flextable::compose( res_ft,
                                  part = "header",
                                  i = 1:n_header_rows,
                                  j = base_col,
                                  flextable::as_paragraph( "N" ) )
  }

  # Add column variable name (unless 1d table)
  if (n_vars > 1) {
    res_ft <-
      flextable::merge_at( res_ft, part="header",
                           i=1, j=1:n_col_categories+1 )

    res_ft <- flextable::compose( res_ft,
                                  part = "header",
                                  i = 1,
                                  j = 2,
                                  flextable::as_paragraph( col_var_name ) )
  }

  # IF metric is percentage or proportion and table is 2- or 3d,
  # update text used to head column, italicising text reporting unit of measure
  if ( n_vars > 1 & metric %in% c("pct", "prop") ) {
    metric_name <- dplyr::case_when ( metric == "pct" ~ "Percent",
                                      metric == "prop" ~ "Proportion" )
    res_ft <-
      flextable::merge_at( res_ft, part="header",
                           i=n_header_rows, j=1:n_col_categories+1 )
    res_ft <-
      flextable::compose( res_ft,
                          part = "header",
                          i = n_header_rows,
                          j = 2,
                          flextable::as_paragraph( flextable::as_i(metric_name ) ) )
  }

  # Centre align header text
  # (except for first column and any Total or base count columns)
  res_ft <-
    flextable::align( res_ft,
                      part = "header",
                      i = 1:n_header_rows,
                      j = c(1:n_col_categories+1),
                      align = "center" )

  # Vertically align text in column 1 of header to bottom of header
  # [2- and 3d tables only]
  if (n_vars > 1) res_ft <-
    flextable::valign( res_ft, part = "header",
                       i = 1, j = 1, valign = "bottom" )
  res_ft

  # Vertically and horizontally align text in Total column of header (if present)
  # [vertical alignment for 2- and 3-d tables only]
  if ( totals %in% c("row", "row_col" ) ) {
    res_ft <- flextable::align( res_ft, part = "header", i = 1, j = total_col,
                                align = "center" )
    if (n_vars > 1) res_ft <-
        flextable::valign( res_ft, part = "header", i = 1, j = total_col,
                           valign = "bottom" )
  }

  # Vertically and horizontally align text in row pct base count column (if any)
  # [vertical alignment for 2- and 3-d tables only]
  if ( base_count == TRUE & metric_type == "row") {
    res_ft <- flextable::align( res_ft, part = "header", i = 1, j = base_col,
                                align = "center" )
    if (n_vars > 1) res_ft <-
        flextable::valign( res_ft, part = "header", i = 1, j = base_col,
                           valign = "bottom" )
  }

  # Correct thickness of horizontal lines in header
  res_ft <- res_ft |>
    flextable::hline_top( part = "header",
                          border = officer::fp_border( width = line_width ) ) |>
    flextable::hline( part = "header",
                      i = c(1:n_header_rows),
                      border = officer::fp_border( width = line_width ) )

  # Format body of table

  # 3d tables only: centre names of 3rd variable categories via merge and align
  if (n_vars == 3) {
    for (i in 1:n_inner_tables) {
      j = 1 + (i-1)*n_inner_table_rows
      res_ft <-
        flextable::merge_at( res_ft, part="body", i=j, j=1:table_cols) |>
        flextable::align( part="body", i=j, align="center")
    }
  }

  # Right-align numeric values of body of table (ironically only
  # required if numbers are supplied as text, but applied here
  # even if numbers are supplied as numbers for safety's sake)
  if (n_vars < 3 ) {
    res_ft <- flextable::align( res_ft, part = "body",
                                j = 2:table_cols, align = "right" )
  } else {
    for (i in 1:n_inner_tables)
      j = (i-1)*n_inner_table_rows
      res_ft <-
        flextable::align( part = "body",
                          j = j+2:j+n_inner_table_rows, align = "right" )
  }

  # Calculate location of the FIRST inner table total_row and base_row (if any)
  if ( base_count == TRUE & metric_type == "col" )
    base_row <- n_inner_table_rows
  if ( totals %in% c("col", "row_col") ) {
    if ( base_count == TRUE & metric_type == "col" ) {
      total_row <- n_inner_table_rows - 1
    } else {
      total_row <- n_inner_table_rows
    }
  }

  # Add horizontal of correct thickness at bottom of each inner table
  for (i in 1:n_inner_tables) {
    j = n_inner_table_rows + ( (i-1) * n_inner_table_rows )
    res_ft <-
      flextable::hline( res_ft,
                        part = "body", i = j,
                        border = officer::fp_border( width = line_width ) )
  }

  # # Add horizontal below each inner table header (3d tables only)
  # for (i in 1:n_inner_tables) {
  #   j = 1 + ( (i-1) * n_inner_table_rows )
  #   res_ft <-
  #     hline( res_ft,
  #            part = "body", i = j,
  #            border = officer::fp_border( width = line_width ) )
  # }

  # Add horizontal lines above total row (if any)
  if ( totals %in% c("col", "row_col") ) {
    for (i in 1:n_inner_tables) {
      # Add line at top of total row
      j = total_row + ( (i-1) * n_inner_table_rows )
      res_ft <- flextable::hline( res_ft, part = "body", i = j -1,
                                  border = officer::fp_border( width = line_width) )
    }
  }

  # Add horizontal above base count row (if any), provided there is no total row
  if ( base_count == TRUE & metric_type == "col" ) {
    if ( totals %in% c("none", "row") ) {
      for (i in 1:n_inner_tables) {
        # Add line above base count row
        j = base_row + ( (i-1) * n_inner_table_rows )
        res_ft <- flextable::hline( res_ft, part = "body", i = j-1,
                                    border = officer::fp_border( width = line_width) )
      }
    }
  }

  # Add publish_tab class to output data object
  class( res_ft )  <- append( class( res_ft ), "publish_tab" )

  return( res_ft )

} # publish_tab
