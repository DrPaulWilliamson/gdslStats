% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/group_data.R
\name{group_data}
\alias{group_data}
\title{Allocated continuous data to groups using user-friendly class labels}
\usage{
group_data(
  data = data,
  method = "equal",
  breaks = 5,
  sep = " to ",
  output.dp = NULL,
  include.lowest = TRUE,
  integer.dp = 6,
  mid.point = FALSE
)
}
\arguments{
\item{data}{A vector of \emph{numeric} values.}

\item{method}{One of "equal" (equal class intervals), "quantile" (equal class observations) or "user" (user-defined class boundaries). Default is "equal".}

\item{breaks}{Either a single number specifying the number of categories required, or a numeric vector specifying the required class boundaries. E.g. \code{c(0, 5, 10, 15)}.}

\item{sep}{The character string used to separate the two parts of a class boundary. Default value: " to ".}

\item{output.dp}{Number of decimal places to be used when reporting class boundaries. Default is to retain the precision of the input values.}

\item{include.lowest}{Logical. If \code{TRUE} (default) the boundaries of the lowest class are defined as  \eqn{ lb \le{x} \lt{ub} } ). See Details.}

\item{integer.dp}{Threshold for identifying a set of \code{data} values as integer. The default is 6 (i.e. treat a set of values in which no fractional part of a number is >= 0.000001 as integer). See Details.}

\item{mid.point}{Logical. If \code{TRUE} then class is labelled by mid-point rather than by class boundaries. Default is \code{FALSE}.}
}
\value{
Factor vector, providing one class label per \code{data} value.
}
\description{
Allocated continuous data to groups using user-friendly class labels
}
\details{
The \code{cut( )} function under-pinning \code{group_data( )} is supplied with a set of class boundaries defining the lowest boundary of the first (lowest) class, and the upper boundary of the first and any subsequent classes.
Class boundaries are defined such that, for any given class, \eqn{ lb \lt{x} \le{ub} }. The one exception to this is the first (lowest) class, for which the lower boundary is defined by the minimum value of \emph{x}. In other words, \eqn{ lb \le{x} \le{ub} }.
Hence if \code{breaks = c(1, 2, 8, 10)}, the following classes will be defined: \eqn{1 \le{x} \le{2}}, \eqn{2 \lt{x} \le{8}}, and \eqn{8 \lt{x} \le{10}}. In this example, a data value of 8 would be allocated to the middle category of \eqn{2 \lt{x} \le{8}} because 8 is less than or equal to the upper class boundary of 8. It would not be allocated to the top category of \eqn{8 \lt{x} \le{10}}, because in the top category the lower boundary of 8 is not less than the data value of 8.
In contrast, a value of 1 would be allocated to the first category, \eqn{1 \le{x} \le{2}}, because the lower bound of 1 is less than or equal to the data value of 1.
To force the treatment of the  lower boundary of the first category to be consistent with the treamtment of the lower boundary of the other categories, set \code{include.lowest} to \code{FALSE}. Note that doing so will leave any observations with a value equal to the lower boundary of the first class unclassified.

Users can choose to change the threshold at which \code{group_data( )} starts to treat values as integer via the \code{integer.dp} option. By default \code{group_data( )} treats a set of values which contain fractional components of 0.000001 or less as a set of integer values. (e.g. the set of values 3.0000001 and 9.000001 would be treated as the integer values 3 and 9.) This is to cater for floating point errors arising from a set of mathematical operations.

The \code{cut( )} function uses a class label of the form \code{[lb,ub]} to indicate a class interval where \eqn{ lb 'le{x} \le{ub} }; and the class label \code{(lb,ub]} to indicate a class interval where \eqn{ lb 'lt{x} \le{ub} }.
\code{group_data( )} replaces this with a class label which is easier to understand (e.g. 1 to 2, 3 to 8, 9 to 10). If the default \code{output.dp} are used, then the class boundaries will be defined in a way which ensures that the boundaries (a) do not overlap and (b) clearly indicate which class every data value falls in.
The default precision (decimal places) used to define the class boundaries matches that of the precision of the input data beingn classified. For example, if the input data is specified to 3 d.p. (e.g. 1.123) then class boundaries of the form 1.000 to 1.777 and 1.778 to 2.412 would be used. As the input data are measured only to 3 d.p., there can be no value of 1.7775, and hence no uncertainty regarding which class each data value will fall in.
However, to make for more readable class labels, the user can request that fewer decimal places are used in the class labels (although full precision will still be used in the class allocation). For example, if the \code{output.dp} were set to 1, data recorded to three decimal places might be classified using the class boundaries 1.000 to 1.777, and 1.778 to 2.412, but labelled as the classes 1.0 to 1.8 and 1.8 to 2.4.
\code{group_data( )} offers two other features not offered by \code{cut( )}. First, it automatically calculates the clas boundaries for quantile-based classes. Second, it automatically identifies and removes any duplicate upper class boundaries. E.g. the set of breaks 0, 2, 2, 2, 4, 8, 10 would automatically be converted into the set of class boundaries 0, 2, 4, 8, 10, accompanied by a warning message that this had been done.
}
\examples{
# Group data into five equal-interval categories
group_data( data = survey$Height, breaks = 5 ) |> table( )

# Report class boundaries to n decimal places
group_data( data = survey$Height, breaks = 5, output.dp = 2 ) |> table( )

# Group data into five quantiles
group_data( data = survey$Height, method = "quantile", breaks = 5,
 output.dp = 2 ) |> levels( )

# Group data into three user-defined categories
group_data( data = survey$Height, method = "user",
  breaks = c(130, 160, 180, 210), output.dp = 2 ) |> table( )

# Report class mid-point instead of upper and lower bounds
group_data( data = survey$Height, breaks = 5, output.dp = 2,
            mid.point = TRUE ) |> table( )

# Threshold for treating a data value as integer rather than continuous
group_data( data = survey$Height, breaks = 5, integer.dp = 0 ) |> table( )

# Change separator used to construct class labels
group_data( data = survey$Height, breaks = 5, integer.dp = 0, sep = "-") |>
 table( )
}
